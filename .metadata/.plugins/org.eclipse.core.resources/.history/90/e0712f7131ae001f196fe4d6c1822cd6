package com.zzt.client.core;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.atomic.AtomicInteger;

import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.recipes.locks.InterProcessMutex;

import com.zzt.client.zk.ZookeeperFactory;

import io.netty.channel.ChannelFuture;

public class ChannelManager {

    static Set<String> realServerPath = new HashSet<>();
    public static CopyOnWriteArrayList<ChannelFuture> channelFutures = new CopyOnWriteArrayList<>();
    private static CuratorFramework client = ZookeeperFactory.create();
    private static final String POSITION_PATH = "/distributed/position";
    private static final InterProcessMutex lock = new InterProcessMutex(client, "/lock/position");

    static {
        try {
            // 初始化 Zookeeper 中的计数器值为 0
            if (client.checkExists().forPath(POSITION_PATH) == null) {
                client.create().creatingParentsIfNeeded().forPath(POSITION_PATH, "0".getBytes());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void removeChannel(ChannelFuture channel) {
        channelFutures.remove(channel);
    }

    public static void addChannel(ChannelFuture channel) {
        channelFutures.add(channel);
    }

    public static void clear() {
        channelFutures.clear();
        try {
            // 清空时重置分布式计数器
            client.setData().forPath(POSITION_PATH, "0".getBytes());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static ChannelFuture get() {
        ChannelFuture channelFuture = null;
        try {
            // 加锁以确保计数器操作的原子性
            lock.acquire();
            String positionData = new String(client.getData().forPath(POSITION_PATH));
            int position = Integer.parseInt(positionData);
            int size = channelFutures.size();

            if (position >= size) {
                channelFuture = channelFutures.get(0); // 重置为第一个通道
                client.setData().forPath(POSITION_PATH, "1".getBytes()); // 重置计数器为 1
            } else {
                channelFuture = channelFutures.get(position);
                client.setData().forPath(POSITION_PATH, String.valueOf(position + 1).getBytes()); // 更新计数器
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                lock.release();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return channelFuture;
    }
}
